# Azure DevOps Pipeline for Laravel Docker Project
# This pipeline builds, tests, and deploys the Laravel application

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    exclude:
      - README.md
      - docs/*

pr:
  branches:
    include:
      - main
      - develop

variables:
  # Build variables
  dockerRegistryServiceConnection: 'docker-registry-connection'
  imageRepository: 'laravel-docker-app'
  containerRegistry: '$(registryName).azurecr.io'
  dockerfilePath: '$(Build.SourcesDirectory)/docker/app/Dockerfile'
  tag: '$(Build.BuildId)'
  
  # Azure Web App variables
  azureSubscription: 'azure-service-connection'
  webAppName: 'laravel-docker-webapp'
  resourceGroupName: 'laravel-docker-rg'
  
  # Environment variables
  vmImageName: 'ubuntu-latest'

stages:
  # Build and Test Stage
  - stage: BuildAndTest
    displayName: 'Build and Test'
    jobs:
      - job: BuildTest
        displayName: 'Build and Test Application'
        pool:
          vmImage: $(vmImageName)
        
        steps:
          # Checkout code
          - checkout: self
            fetchDepth: 0
          
          # Setup Docker Buildx
          - task: DockerInstaller@0
            displayName: 'Install Docker'
            inputs:
              dockerVersion: '20.10.7'
          
          # Create environment file for testing
          - task: Bash@3
            displayName: 'Setup Environment'
            inputs:
              targetType: 'inline'
              script: |
                cp src/env.template src/.env
                # Set test database configuration
                sed -i 's/DB_CONNECTION=mysql/DB_CONNECTION=sqlite/' src/.env
                sed -i 's/DB_DATABASE=laravel/DB_DATABASE=:memory:/' src/.env
          
          # Build application container
          - task: Docker@2
            displayName: 'Build Application Image'
            inputs:
              command: 'build'
              dockerfile: '$(dockerfilePath)'
              buildContext: '$(Build.SourcesDirectory)'
              repository: '$(imageRepository)'
              tags: |
                $(tag)
                latest
              arguments: '--target development'
          
          # Start services for testing
          - task: Bash@3
            displayName: 'Start Test Environment'
            inputs:
              targetType: 'inline'
              script: |
                # Create docker-compose override for CI
                cat > docker-compose.ci.yml << EOF
                version: '3.8'
                services:
                  app:
                    build:
                      context: .
                      dockerfile: docker/app/Dockerfile
                      target: development
                    environment:
                      - APP_ENV=testing
                      - DB_CONNECTION=sqlite
                      - DB_DATABASE=:memory:
                      - CACHE_DRIVER=array
                      - SESSION_DRIVER=array
                      - QUEUE_CONNECTION=sync
                  mysql:
                    image: mysql:8.0
                    environment:
                      MYSQL_ROOT_PASSWORD: secret
                      MYSQL_DATABASE: laravel_test
                      MYSQL_USER: laravel
                      MYSQL_PASSWORD: laravel
                    tmpfs:
                      - /var/lib/mysql
                EOF
                
                # Start services
                docker-compose -f docker-compose.yml -f docker-compose.ci.yml up -d app mysql redis
                
                # Wait for services to be ready
                sleep 30
          
          # Install dependencies
          - task: Bash@3
            displayName: 'Install Dependencies'
            inputs:
              targetType: 'inline'
              script: |
                docker-compose exec -T app composer install --no-interaction --prefer-dist --optimize-autoloader
                docker-compose exec -T app php artisan key:generate
          
          # Run code quality checks
          - task: Bash@3
            displayName: 'Code Quality Checks'
            inputs:
              targetType: 'inline'
              script: |
                echo "Running PHP CS Fixer..."
                docker-compose exec -T app ./vendor/bin/php-cs-fixer fix --dry-run --diff --verbose || echo "Code formatting issues found"
                
                echo "Running PHPCS..."
                docker-compose exec -T app ./vendor/bin/phpcs --report=checkstyle --report-file=/tmp/phpcs-report.xml || echo "PHPCS issues found"
                
                echo "Running PHPStan..."
                docker-compose exec -T app ./vendor/bin/phpstan analyse --error-format=checkstyle --no-progress > /tmp/phpstan-report.xml || echo "PHPStan issues found"
          
          # Run tests
          - task: Bash@3
            displayName: 'Run Unit and Feature Tests'
            inputs:
              targetType: 'inline'
              script: |
                docker-compose exec -T app php artisan test --coverage --coverage-clover=/tmp/coverage.xml
          
          # Copy test results
          - task: Bash@3
            displayName: 'Copy Test Results'
            inputs:
              targetType: 'inline'
              script: |
                # Create results directory
                mkdir -p $(Agent.TempDirectory)/test-results
                
                # Copy test results from container
                docker cp $(docker-compose ps -q app):/tmp/coverage.xml $(Agent.TempDirectory)/test-results/ || echo "No coverage file found"
                docker cp $(docker-compose ps -q app):/tmp/phpcs-report.xml $(Agent.TempDirectory)/test-results/ || echo "No PHPCS report found"
                docker cp $(docker-compose ps -q app):/tmp/phpstan-report.xml $(Agent.TempDirectory)/test-results/ || echo "No PHPStan report found"
          
          # Publish test results
          - task: PublishTestResults@2
            displayName: 'Publish Test Results'
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '$(Agent.TempDirectory)/test-results/*.xml'
              failTaskOnFailedTests: false
            condition: always()
          
          # Publish code coverage
          - task: PublishCodeCoverageResults@1
            displayName: 'Publish Code Coverage'
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '$(Agent.TempDirectory)/test-results/coverage.xml'
            condition: always()
          
          # Stop test environment
          - task: Bash@3
            displayName: 'Cleanup Test Environment'
            inputs:
              targetType: 'inline'
              script: |
                docker-compose -f docker-compose.yml -f docker-compose.ci.yml down -v
            condition: always()

  # Build Production Images Stage
  - stage: BuildProduction
    displayName: 'Build Production Images'
    dependsOn: BuildAndTest
    condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
    jobs:
      - job: BuildProd
        displayName: 'Build Production Images'
        pool:
          vmImage: $(vmImageName)
        
        steps:
          - checkout: self
          
          # Login to Azure Container Registry
          - task: Docker@2
            displayName: 'Login to Container Registry'
            inputs:
              command: 'login'
              containerRegistry: $(dockerRegistryServiceConnection)
          
          # Build and push application image
          - task: Docker@2
            displayName: 'Build and Push Application Image'
            inputs:
              command: 'buildAndPush'
              repository: '$(imageRepository)'
              dockerfile: '$(dockerfilePath)'
              buildContext: '$(Build.SourcesDirectory)'
              tags: |
                $(tag)
                latest
              arguments: '--target production'
          
          # Build and push Nginx image
          - task: Docker@2
            displayName: 'Build and Push Nginx Image'
            inputs:
              command: 'buildAndPush'
              repository: '$(imageRepository)-nginx'
              dockerfile: '$(Build.SourcesDirectory)/docker/nginx/Dockerfile'
              buildContext: '$(Build.SourcesDirectory)'
              tags: |
                $(tag)
                latest

  # Deploy to Staging
  - stage: DeployStaging
    displayName: 'Deploy to Staging'
    dependsOn: BuildProduction
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
    jobs:
      - deployment: DeployToStaging
        displayName: 'Deploy to Staging Environment'
        pool:
          vmImage: $(vmImageName)
        environment: 'staging'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                
                # Download secure files (if needed)
                - task: DownloadSecureFile@1
                  name: envStaging
                  displayName: 'Download Staging Environment File'
                  inputs:
                    secureFile: '.env.staging'
                
                # Deploy to Azure Container Instances (Staging)
                - task: AzureContainerApps@1
                  displayName: 'Deploy to Azure Container Apps (Staging)'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    containerAppName: '$(webAppName)-staging'
                    resourceGroup: $(resourceGroupName)
                    imageToDeploy: '$(containerRegistry)/$(imageRepository):$(tag)'

  # Deploy to Production
  - stage: DeployProduction
    displayName: 'Deploy to Production'
    dependsOn: BuildProduction
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: DeployToProduction
        displayName: 'Deploy to Production Environment'
        pool:
          vmImage: $(vmImageName)
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                
                # Download secure files
                - task: DownloadSecureFile@1
                  name: envProduction
                  displayName: 'Download Production Environment File'
                  inputs:
                    secureFile: '.env.production'
                
                # Deploy to Azure Web App
                - task: AzureWebAppContainer@1
                  displayName: 'Deploy to Azure Web App'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    appName: $(webAppName)
                    containers: '$(containerRegistry)/$(imageRepository):$(tag)'

  # Post-deployment tests
  - stage: PostDeploymentTests
    displayName: 'Post-deployment Tests'
    dependsOn: 
      - DeployStaging
      - DeployProduction
    condition: or(succeeded('DeployStaging'), succeeded('DeployProduction'))
    jobs:
      - job: SmokeTests
        displayName: 'Run Smoke Tests'
        pool:
          vmImage: $(vmImageName)
        
        steps:
          - task: Bash@3
            displayName: 'Health Check Tests'
            inputs:
              targetType: 'inline'
              script: |
                # Determine the environment URL
                if [ "$(Build.SourceBranch)" = "refs/heads/main" ]; then
                  APP_URL="https://$(webAppName).azurewebsites.net"
                else
                  APP_URL="https://$(webAppName)-staging.azurewebsites.net"
                fi
                
                echo "Testing application at: $APP_URL"
                
                # Wait for deployment to be ready
                sleep 60
                
                # Test health endpoint
                response=$(curl -s -o /dev/null -w "%{http_code}" "$APP_URL/health" || echo "000")
                if [ "$response" = "200" ]; then
                  echo "✅ Health check passed"
                else
                  echo "❌ Health check failed with status: $response"
                  exit 1
                fi
                
                # Test API endpoint
                response=$(curl -s -o /dev/null -w "%{http_code}" "$APP_URL/api/status" || echo "000")
                if [ "$response" = "200" ]; then
                  echo "✅ API check passed"
                else
                  echo "❌ API check failed with status: $response"
                  exit 1
                fi
                
                echo "🎉 All smoke tests passed!"
